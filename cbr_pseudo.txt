case = 5x5 grid, each cell takes on one of 12 string values: 0-8(num adjacent mines), -(covered), F (flag), W(wall)

def convertToCase(cell) - gets 5x5 sample centered on cell, returns case

def getFrontierCells() - returns a list of all 'frontier cells' - the covered cells that are on the border between covered-uncovered cells.

def retrieveSimilarCases() - returns a list of all cases that are ranked to be most similar using K-means clustering.

def getSolutionAndConfidence() - returns already used solution if an exact case match is found. Otherwise a solution is adapted from the similar cases. Confidence score 0.0 - 1.0 too.

def evaluate(cases) - decides whether or not to retain cases. Might adapt them (generalise) before adding to case base.

prev_case = None
flagged_cases_with_coords = []

# Must return (x, y, is_flag)
def next(self):
    frontier_cells = getFrontierCells(grid)

    most_likely = (None, None, 0)

    for cell in frontier_cells:
        case = convertToCase(cell)
        similar_cases = retrieveSimilarCases()
        (is_mine, confidence) = getSolutionAndConfidence(case, similar_cases)

        if confidence == 1.0:
            most_likely = (case, confidence)
            break
        
        most_likely = max(most_likely.confidence, confidence)
    
    most_likely.case.solution = flag_the_cell
    prev_case = most_likely.case
    cell = most_likely.case.center_cell
    return (cell.x, cell.y, flag_the_cell)


def result(self, grid, game_state):
    if game_state = GameState.WON:
        gameWon(grid)
    elif game_state = GameState.LOST:
        gameLost(grid)
    else:
        moveMade(grid)


def gameLost(self, grid):
    cases_to_evaluate = []

    # Learn from previous move
    prev_case.is_mine = True

    # Learn flagged cases
    for (case, coords) in flagged_cases_with_coords:
        x, y = coords
        case.is_mine = grid[x][y].is_mine

    evaluate(cases_to_evaluate)


def gameWon(self, grid):
    evaluate(prev_case)

def moveMade(self, grid):
    

